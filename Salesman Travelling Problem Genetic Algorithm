const cities: string[] = ["1","2","3","4"];
const roadsData: {startNode: string; endNode: string; edgeWeight: number}[] = [
    {startNode: "1", endNode: "2", edgeWeight: 10},
    {startNode: "1", endNode: "4", edgeWeight: 20},
    {startNode: "1", endNode: "3", edgeWeight: 15},
    {startNode: "2", endNode: "1", edgeWeight: 10},
    {startNode: "2", endNode: "4", edgeWeight: 25},
    {startNode: "2", endNode: "3", edgeWeight: 35},
    {startNode: "3", endNode: "1", edgeWeight: 15},
    {startNode: "3", endNode: "4", edgeWeight: 30},
    {startNode: "3", endNode: "2", edgeWeight: 35},
    {startNode: "4", endNode: "1", edgeWeight: 20},
    {startNode: "4", endNode: "2", edgeWeight: 25},
    {startNode: "4", endNode: "3", edgeWeight: 30},
];

//Graful este cromozomul (structura solutiei)
//array-ul nodes contine genele (componentele solutiei)
class Graph{
   private nodes: string[];
   private adjacencyList: {[key: string]: {[key: string]: number}};

   constructor() {
    this.nodes = [];
    this.adjacencyList = {};
   } 

   addNode(node: string) {
    this.nodes.push(node);
    this.adjacencyList[node] = {};
   }

   addEdge(startNode: string, endNode: string, edgeWeight: number)
   {
        this.adjacencyList[startNode][endNode] = edgeWeight;
   }

   getNodes(): string[] {
    return this.nodes;
   }

   getAdjacencyList():{[key: string]: {[key: string]: number}} {
        return this.adjacencyList;
   }

   getTotalWeight(): number {
    let totalWeight: number = 0 
    for(let index = 0; index < this.nodes.length -1; index++ ) {
        totalWeight += this.adjacencyList[this.nodes[index]][this.nodes[index+1]];
    }
    return totalWeight;
   }
}


class TravellingSalesman {
    private population: Graph[] = [];
    private crossoverRate: number = 0.7;
    private mutationRate: number = 0.1;

    initializeFirstGeneration(populationSize: number): void {
        for(let index = 0; index < populationSize; index++) {
            let graph = new Graph();
            let randomNumber = this.getRandomNumber();
            for(let nodeIndex = 0; nodeIndex < randomNumber; nodeIndex++ ) {
                let randomNode: string = cities[nodeIndex];
                graph.addNode(randomNode);
                for(let edgeData of roadsData) {
                    if(edgeData.startNode === randomNode) {
                        graph.addEdge(edgeData.startNode,edgeData.endNode,edgeData.edgeWeight);
                    }
                }
            } 
            this.population = [...this.population, graph];
        }
    }

    private getRandomNumber(): number {
        return Math.floor(Math.random() * 4);
    }

     displayCurrentPopulation(): void {
        this.population.forEach((graph: Graph, index) => {
            console.error(`Graph ${index + 1}`, graph);
        });
    }

    private fitness(graph: Graph): number {
        return Math.abs(graph.getTotalWeight());
    }

    private selectParentTournament(tournamentSize: number): Graph {
        let tournamentWinner: Graph = this.population[this.getRandomNumber()];
        for(let index = 0; index < tournamentSize; index++ ) {
            let opponent: Graph = this.population[this.getRandomNumber()];
            if(this.fitness(tournamentWinner) < this.fitness(opponent)) {
                tournamentWinner = opponent;
            }
        }
        return tournamentWinner;
    }

    crossover(parent1: Graph, parent2: Graph): Graph {
        let child: Graph = new Graph();
        for(let index = 0; index < Math.floor(parent1.getNodes().length/2); index++ ) {
            child.addNode(parent1.getNodes()[index]);
        }
        for(let index2 = Math.floor(parent2.getNodes().length/2); index2 < parent2.getNodes().length; index2++) {
            child.addNode(parent2.getNodes()[index2]);
        }
        return child;
    }

    mutation(child: Graph): Graph {
        let randomNode: number = this.getRandomNumber();
        let randomCity: number = this.getRandomNumber();
        child.getNodes()[randomNode] = cities[randomCity];
        delete child.getAdjacencyList()[randomNode];
        roadsData.forEach((road) => {
            if(road.startNode === randomCity.toString()) {
                child.addEdge(road.startNode,road.endNode,road.edgeWeight);
            }
        });
        return child;
    }

    evolvePopulation(): void {
        let newGeneration: Graph[] = [];
        for(let graphIndex = 0; graphIndex < this.population.length; graphIndex++){
            let parent1 = this.selectParentTournament(2);
            let parent2 = this.selectParentTournament(2);
            let child: Graph;
            if(Math.random() < this.crossoverRate) {
                child = this.crossover(parent1,parent2);
            } else {
                child = parent1;
            }
            if(Math.random() < this.mutationRate) {
                this.mutation(child);
            }
            newGeneration.push(child);
        }
        this.population = newGeneration;
    }

    stopEvolution(startingPoint: string): boolean {
        let validSolution: number = 0;
        this.population.forEach((graph) => {
            if(this.checkGraphValidity(graph, startingPoint)) {
                validSolution++;
            }
        });
        if(validSolution >= 1) {
            return true;
        }
        return false;
    }

    private checkGraphValidity(graph: Graph, startingPoint: string): boolean {
        let isGraphValid: boolean = true;
        for(let index = 0; index < graph.getNodes().length - 1; index++) {
            if(graph.getNodes()[index] > graph.getNodes()[index+1]) {
                isGraphValid = false;
            }
        }
        if(graph.getNodes()[0] !== startingPoint && graph.getNodes()[graph.getNodes().length-1] !== startingPoint ) {
            isGraphValid = false;
        }
        return isGraphValid;
    }   

    getBestRoad(): Graph {
        return this.population.reduce((best, graph) => this.fitness(graph) > this.fitness(best) ? graph : best);
    }

}

const salesman = new TravellingSalesman();
salesman.initializeFirstGeneration(10);
while(!salesman.stopEvolution("1")) {
    salesman.evolvePopulation();
}
salesman.displayCurrentPopulation();
salesman.getBestRoad();
